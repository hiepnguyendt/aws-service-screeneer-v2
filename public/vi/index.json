[
{
	"uri": "/vi/",
	"title": "AWS RDS PostgreSQL",
	"tags": [],
	"description": "",
	"content": "Bắt đầu với AWS RDS PostgreSQL Tổng quan Trong bài thực hành này, Bạn sẽ tìm hiểu và thực hành những kiến thức cơ bản về Amazon RDS PostgreSQL.\nNội dung Giới thiệu Các bước chuẩn bị Bắt đầu với PostgreSQL Tạo RDS PostgreSQL Database instance Kết nối đến pgAdmin4 Nguồn học Clean up "
},
{
	"uri": "/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": " PostgreSQL đã trở thành cơ sở dữ liệu quan hệ mã nguồn mở dành cho nhiều nhà phát triển doanh nghiệp và người khởi nghiệp, hỗ trợ các ứng dụng di động và kinh doanh hàng đầu. Amazon RDS giúp việc thiết lập, vận hành và mở rộng quy mô triển khai PostgreSQL trên đám mây trở nên dễ dàng hơn. Với Amazon RDS, bạn có thể triển khai PostgreSQL trong vài phút với dung lượng phần cứng có thể thay đổi và tiết kiệm chi phí. Amazon RDS quản lý các tác vụ quản trị phức tạp và tốn thời gian như cài đặt và nâng cấp phần mềm PostgreSQL, quản lý lưu trữ, sao chép để có tính sẵn sàng cao và thông lượng đọc cũng như sao lưu để khắc phục thảm họa.\nAmazon RDS PostgreSQL cung cấp cho bạn quyền truy cập vào các công cụ của cơ sở dữ liệu PostgreSQL. Điều này có nghĩa là code, ứng dụng và công cụ bạn hiện đang sử dụng với cơ sở dữ liệu hiện tại của mình có thể được sử dụng với Amazon RDS. Amazon RDS PostgreSQL hiện hỗ trợ các phiên bản PostgreSQL 9.6, 10, 11, 12, 13, 14 và 15. Với Trusted Language Extensions (TLE) for PostgreSQL, bạn có thể xây dựng các tiện ích mở rộng hiệu suất cao và chạy chúng một cách an toàn trên Amazon RDS bằng các ngôn ngữ phổ biến đáng tin cậy mà không cần AWS xác thực code.\nNhững lợi ích bạn sẽ nhận được khi sử dụng AWS RDS PostgreSQL\nTriển khai quản lí dễ dàng hơn Lưu trữ nhanh, có thể dự báo Sao lưu và phục hồi Tính sẵn sàng cao và bản sao chỉ có quyền đọc Giám sát và đo lường Cách ly và bảo mật "
},
{
	"uri": "/vi/3-startwithpostgresql/3-1-pgadmin/",
	"title": "pgAdmin4 tool",
	"tags": [],
	"description": "",
	"content": " Công cụ pgAdmin4 là một nền tảng phát triển và quản trị cơ sở dữ liệu rất phổ biến dành cho cơ sở dữ liệu PostgreSQL. Chúng tôi sẽ sử dụng pgAdmin để giới thiệu về PostgreSQL cho bạn.\n![pgadmin4layout](/images/2/2-1/pgadminlayout.png)\rpgAdmin có thể được cài đặt cục bộ trên máy tính của bạn hoặc nó có thể chạy trên máy chủ và được truy cập thông qua trình duyệt web. Trong lab này, chúng ta sẽ triển khai pgAdmin trên máy tính của bạn thông qua link download image.\n"
},
{
	"uri": "/vi/4-connectordspostgresql/4-1-usingpgadmin4/",
	"title": "Sử dụng pgAdmin4 để kết nối đến RDS PostgreSQL",
	"tags": [],
	"description": "",
	"content": "\rTrong phần này, chúng tôi sẽ sử dụng pgAdmin4 để kết nối với RDS cho phiên bản DB PostgreSQL, vì vậy chúng tôi cần tạo DB ở chế độ công khai.\nBạn có thể sử dụng công cụ nguồn mở pgAdmin4 để kết nối với phiên bản RDS cho PostgreSQL DB của mình. Bạn có thể tải xuống và cài đặt pgAdmin từ http://www.pgadmin.org/ mà không cần có phiên bản cục bộ của PostgreSQL trên máy khách của bạn\nKhởi chạy ứng dụng pgAdmin4 trên máy của bạn.\\\nTrên tab Dashboard, chọn Add New Server. Trong hộp thoại Create - Server, nhập tên trên tab General để xác định máy chủ trong pgAdmin4.\nTrong tab Connection, nhập thông tin sau từ DB instance của bạn:\nĐối với Host, Endpoint của RDS PostgreSQL DB, ví dụ mypostgresql.c6c8dntfzzhgv0.us-east-2.rds.amazonaws.com. Đối với Port, nhập port được chỉ định. Đối với Username, nhập tên người dùng mà bạn đã nhập khi tạo DB instance. Đối với Password, nhập mật khẩu bạn đã nhập khi tạo DB instance. Trong tab Đường hầm SSH, bật tính năng đường hầm SSH và nhập thông tin sau\nĐối với Host: Tên máy chủ hoặc địa chỉ IP của máy chủ pháo đài. Đối với Port: Số cổng SSH. Đối với Tên người dùng: Tên người dùng mà bạn sử dụng để SSH vào máy chủ pháo đài. Đối với Identity file: chọn cặp khóa bạn đã chọn khi tạo máy chủ pháo đài ec2. Chọn Save.\nServer đã được thêm vào pgAdmin4 và bảng điều khiển của nó hiển thị trên màn hình: Nếu bạn gặp bất kỳ sự cố nào khi kết nối, hãy xem Khắc phục sự cố kết nối với RDS for PostgreSQL instance.\n"
},
{
	"uri": "/vi/2-preparation/2-1-createvpc/",
	"title": "Tạo VPC",
	"tags": [],
	"description": "",
	"content": " Truy cập giao diện VPC console và nhấn Create VPC.\nỞ phần Resources to create, chọn VPC and more.\nĐặt tên cho VPC của bạn và chọn CIDR block. CIDR block là dải địa chỉ IP có sẵn cho VPC của bạn. Hãy chắc chắn rằng bạn đã chọn CIDR block đủ lớn để phù hợp với nhu cầu của bạn nhưng quá lớn dẫn đến lãng phí địa chỉ IP\nChọn giá trị cho Number of public subnets, Number of private subnets và NAT Gateway.\nXem lại tài nguyên VPC của bạn, sau đó click Create VPC\n"
},
{
	"uri": "/vi/2-preparation/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Tổng quan Trong phần này, chúng tôi sẽ chuẩn bị tất cả tài nguyên cho các bài thực hành về RDS PostgreSQL. Nội dung Tạo VPC Tạo EC2 Security Group Tạo RDS Security Group Tạo DB Subnet Group Tạo EC2 AppServer Tạo EC2 bastion host Tạo RDS PostgreSQl Tạo "
},
{
	"uri": "/vi/3-startwithpostgresql/3-2-databaseschemas/",
	"title": "Database và Schemas",
	"tags": [],
	"description": "",
	"content": "Chào mừng đến với PostgreSQL! Nếu đây là lần đầu tiên bạn tìm hiểu về PostgreSQL, chúng tôi khuyến khích bạn xem trang web chính thức Giới thiệu về PostgreSQL.\nTrong module này, chúng ta sẽ tìm hiểu về Databases và Schemas.\nVui lòng hoàn thành việc cài đặt và cấu hình trước khi tiếp tục tìm hiểu về module này.\nTìm hiểu về Databases Trong pgAdmin tool, hãy nhấp vào \u0026gt; ở phía trước rdspg-fcj-labs để mở rộng nó. Bạn thấy 3 mục: Databases, Login/Group Roles, and Tablespaces.\nTrong phần này, chúng ta sẽ tập trung vào Databases. Và chúng ta sẽ đề cập đến Login/Group trong phần sau.\nTìm hiểu về Databases node. Theo thuật ngữ ngành, PostgreSQL instance (rdspg-fcj-labs) mà bạn đã tạo được gọi là cụm PostgreSQL. Một cụm chứa một hoặc nhiều cơ sở dữ liệu. Mặc dù users/roles của một cụm được chia sẻ nhưng không có dữ liệu nào được chia sẻ trên các cơ sở dữ liệu. Nói cách khác, khi khách hàng kết nối với một cụm, kết nối đó bắt buộc phải chỉ định cơ sở dữ liệu mà họ muốn làm việc và kết nối đó chỉ có thể hoạt động trong một cơ sở dữ liệu tại một thời điểm.\nbạn sẽ thấy một số cơ sở dữ liệu trong cụm pglab.\nCơ sở dữ liệu `rdsadmin` là gì?\rCơ sở dữ liệu có tên rdsadmin là cơ sở dữ liệu được dành riêng để sử dụng bởi RDS/Aurora.\rNhấp chuột phải vào Databases và chọn Create, sau đó nhấp vào Databases Đặt tên cơ sở dữ liệu là first_database (nhưng chưa lưu) Mọi cơ sở dữ liệu đều có chủ sở hữu, đây là vai trò có toàn quyền kiểm soát cơ sở dữ liệu và có thể gán quyền cho các vai trò khác. Theo mặc định, khi cơ sở dữ liệu được tạo trong PostgreSQL, vai trò được sử dụng để tạo cơ sở dữ liệu sẽ trở thành chủ sở hữu của cơ sở dữ liệu đó. Trong PGAdmin, vai trò bạn đăng nhập thường sẽ được đặt làm chủ sở hữu cơ sở dữ liệu mà bạn hiện đang làm việc. Điều đáng nói là PostgreSQL cho phép bạn thay đổi chủ sở hữu của hầu hết các đối tượng cơ sở dữ liệu ngay cả sau khi chúng đã được tạo\nHãy nhấp vào tab Definition Có nhiều cài đặt khác nhau có thể thay đổi được. Bạn không cần phải thay đổi bất cứ điều gì bây giờ.\n6. Nhấp vào tab SQL Tab SQL hiển thị cho bạn bản xem trước của lệnh SQL được tạo mà pgAdmin sẽ chạy.\nClick Save Tìm cơ sở dữ liệu mới của bạn trong trình điều hướng và mở rộng nó. Tìm hiểu về Schemas Cơ sở dữ liệu chứa một hoặc nhiều Schemas được đặt tên, lần lượt chứa các bảng và các đối tượng khác như dạng views và functions. Trong PostgreSQL, các đối tượng trong một Schemas có thể có các chủ sở hữu khác nhau và quyền sở hữu Schemas đó không phụ thuộc vào tên lược đồ.\nNhư được mô tả trong tài liệu về PostgreSQL \u0026ldquo;Tên đối tượng giống nhau có thể được sử dụng trong các Schemas khác nhau mà không có xung đột; ví dụ: cả schema1 và myschema đều có thể chứa các bảng có tên mytable. Không giống như Databases, các Schemas không được phân tách một cách cứng nhắc: người dùng có thể truy cập các đối tượng trong bất kỳ Schemas nào trong cơ sở dữ liệu mà anh ta kết nối tới, nếu anh ta có đặc quyền làm như vậy.\nCó một số lý do tại sao người ta muốn sử dụng schemas:\nCho phép nhiều người sử dụng cùng sử dụng một cơ sở dữ liệu mà không can thiệp lẫn nhau. Để tổ chức các đối tượng cơ sở dữ liệu thành các nhóm logic để dễ quản lý hơn. Các ứng dụng của bên thứ ba có thể được đưa vào các Schemas riêng biệt để chúng không thể xung đột với tên của các đối tượng khác. Các Schemas tương tự như các thư mục ở cấp độ hệ điều hành, ngoại trừ các Schemas đó không thể lồng vào nhau.\u0026rdquo;\nClick vào Schemas và xem các public schema mặc định.\nNhấp chuột phải vào Schemas và chọn Create, sau đó nhấp vào Schema.\nĐặt tên cho schema là first_schema\nCác schemas có chủ sở hữu và có các quyền bảo mật cũng như các đặc quyền mặc định cho các đối tượng mới được tạo trong schema (bạn có thể nhấp vào Security tab và the Default Permissions trong hộp thoại Tạo schema nếu muốn).\nNhấp vào Save để tạo schema. lược đồ của PostgreSQL có thể khác với cách các cơ sở dữ liệu khác như Oracle triển khai các lược đồ. Trong Oracle, các lược đồ được ánh xạ trực tiếp 1:1 tới người dùng. Trong PostgreSQL, các lược đồ không được kết hợp trực tiếp với một người dùng (vai trò) cụ thể.\nNhư đã thảo luận trong tài liệu ,\n\u0026ldquo;Trong tiêu chuẩn SQL, khái niệm các đối tượng trong cùng một schema được sở hữu bởi những người dùng khác nhau không tồn tại. Hơn nữa, một số cách triển khai không cho phép bạn tạo các schema có tên khác với tên chủ sở hữu của chúng. Trên thực tế, các khái niệm về schema và người dùng gần như tương đương trong một hệ thống cơ sở dữ liệu chỉ triển khai hỗ trợ schema cơ bản được quy định trong tiêu chuẩn. Do đó, nhiều người dùng coi những tên đủ điều kiện thực sự bao gồm tên người dùng.tablename. Đây là cách PostgreSQL hoạt động hiệu quả nếu bạn tạo schema cho mọi người dùng. Ngoài ra, không có khái niệm về public schema trong tiêu chuẩn SQL. Để tuân thủ tối đa tiêu chuẩn, bạn không nên sử dụng (thậm chí có thể xóa) public schema.\u0026rdquo;\nLưu ý về search_path Việc tham chiếu các đối tượng thông qua các tên Đủ điều kiện, chẳng hạn như first_schema.first_table, rất tẻ nhạt khi viết và việc mã hóa cứng một tên lược đồ cụ thể vào một ứng dụng là không lý tưởng. Giải pháp là sử dụng các tên không đủ tiêu chuẩn, chẳng hạn như first_table và điều này có thể thực hiện được thông qua search_path của PostgreSQL.\nNhư đã thảo luận trong tài liệu ,\n\u0026ldquo;Hệ thống xác định bảng nào có nghĩa bằng cách đi theo search_path, đây là danh sách các schema cần tìm. Bảng khớp đầu tiên trong đường dẫn tìm kiếm được coi là bảng mong muốn. Nếu không có bảng khớp nào trong đường dẫn tìm kiếm, một lỗi được báo cáo, ngay cả khi tên bảng trùng khớp tồn tại trong các lược đồ khác trong cơ sở dữ liệu.\nSchema đầu tiên có tên trong đường dẫn tìm kiếm được gọi là schema hiện tại. Ngoài việc là lược đồ đầu tiên được tìm kiếm, nó còn là schema trong đó các bảng mới sẽ được tạo nếu lệnh CREATE TABLE không chỉ định tên schema.\u0026rdquo;\nTheo mặc định, search_path được đặt thành $user,public. Như tài liệu nêu\n\u0026ldquo;Phần tử đầu tiên chỉ định rằng một schema có cùng tên với người dùng hiện tại sẽ được tìm kiếm. Nếu không có schema như vậy tồn tại, mục nhập sẽ bị bỏ qua. Phần tử thứ hai đề cập đến lược đồ công khai mà chúng ta đã thấy.\u0026rdquo;\nCần lưu ý rằng PostgreSQL không có khái niệm từ đồng nghĩa như một số cơ sở dữ liệu khác. Bạn có thể sử dụng search_path để xử lý một số, nhưng không phải tất cả, khả năng mà từ đồng nghĩa cung cấp. Để biết ví dụ về cách triển khai chức năng giống từ đồng nghĩa khác trong PostgreSQL, hãy xem blog này.\nChúc mừng!\nBạn đã tìm hiểu những kiến thức cơ bản về Databases và Schema trong PostgreSQL.\n"
},
{
	"uri": "/vi/4-connectordspostgresql/4-2-usingpsql/",
	"title": "Sử dụng EC2 instance để kết nối với RDS PostgreSQL",
	"tags": [],
	"description": "",
	"content": "Để kết nối đến RDS PostgreSQL DB bằng EC2 instance, hãy làm theo các bước sau: Kết nối đến EC2 instance (App server) bằng MobaXterm. Tải và cài đặt bản cập nhật hệ điều hành linux. Bạn có thể sử dụng lệnh sau để tải và cài đặt: cat /etc/os-release cat /etc/system-release\rsudo yum update -y Thêm kho lưu trữ bổ sung PostgreSQL Amazon PostgreSQL is part of the amazon extras library.\nĐể kiểm tra phiên bản postgresql có sẵn trong kho lưu trữ bổ sung của Amazon:\namazon-linux-extras | grep postgresql Để kích hoạt kho lưu trữ bổ sung của Amazon:\nsudo amazon-linux-extras enable postgresql14 Cài đặt psql client: sudo amazon-linux-extras install postgresql14\nCài đặt pgbench: sudo yum install postgresql-contrib\nKiểm tra psql \u0026amp; pgbench psql --version\rpgbench --version Kết nối đến RDS PostgreSQL: psql -h rdspg-fcj-labs.cssuddr073hp.us-east-1.rds.amazonaws.com -U masteruser -d pglab\n-h: RDS PostgreSQL endpoint -U: username for the master user of your database instance -d: name for database "
},
{
	"uri": "/vi/2-preparation/2-2-createec2sg/",
	"title": "Tạo EC2 Security Group",
	"tags": [],
	"description": "",
	"content": "Tạo EC2 security group bằng giao diện AWS console: Truy cập giao diện EC2 console.\nChọn Security Groups.\nChọn Create Security Group.\nTại mục VPC, chọn VPC bạn muốn tạo security group.\nTại mục Security group name, nhập tên cho security group.\nTại mục Description, nhập mô tả cho security group.\nCấu hình Inbound Rule\nCấu hình Outbound Rule\nClick Create.\nBạn đã tạo thành công security group cho EC2 instance.\n"
},
{
	"uri": "/vi/3-startwithpostgresql/",
	"title": "Bắt đầu với PostgreSQL",
	"tags": [],
	"description": "",
	"content": "Nội dung pgAdmin Database và Schemas Tables và Datatypes Basic DML Role và Users Catalog và Data dictionary Session parameters "
},
{
	"uri": "/vi/3-startwithpostgresql/3-3-tablesdatatypes/",
	"title": "Tables và Datatypes",
	"tags": [],
	"description": "",
	"content": "Trong module này, chúng ta sẽ tìm hiểu vè Tables và Datatypes. Hoàn thành module Databases và Schema trước khi tìm hiểu về Tables và Datatypes ở module này.\nBảng là gì và tại sao đôi khi tôi thấy PostgreSQL gọi chúng là Quan hệ?\nTừ Tài liệu PostgreSQL ,\n\u0026ldquo;PostgreSQL là một hệ thống quản lý cơ sở dữ liệu quan hệ (RDBMS). Điều đó có nghĩa là nó là một hệ thống để quản lý dữ liệu được lưu trữ trong các mối quan hệ. Mối quan hệ về cơ bản là một thuật ngữ toán học cho bảng. Khái niệm lưu trữ dữ liệu trong bảng ngày nay phổ biến đến mức nó có vẻ như vốn có hiển nhiên, nhưng có một số cách khác để tổ chức cơ sở dữ liệu. Các tập tin và thư mục trên các hệ điều hành giống Unix là một ví dụ về cơ sở dữ liệu phân cấp. Một sự phát triển hiện đại hơn là cơ sở dữ liệu hướng đối tượng.\nMỗi bảng là một tập hợp các hàng được đặt tên. Mỗi hàng của một bảng nhất định có cùng một tập hợp các cột được đặt tên và mỗi cột thuộc một kiểu dữ liệu cụ thể. Trong khi các cột có thứ tự cố định trong mỗi hàng, điều quan trọng cần nhớ là SQL không đảm bảo thứ tự của các hàng trong bảng theo bất kỳ cách nào (mặc dù chúng có thể được sắp xếp rõ ràng để hiển thị).\nCác bảng được nhóm thành cơ sở dữ liệu và tập hợp cơ sở dữ liệu được quản lý bởi một phiên bản máy chủ PostgreSQL duy nhất tạo thành một cụm cơ sở dữ liệu.\u0026rdquo;\nTìm hiểu về Tables Trong pgAdmin tool, hãy mở rộng first_schema bên trong first_database của bạn. Các loại đối tượng khác nhau (tables, views, functions,\u0026hellip;) có thể là một phần của PostgreSQL schema.\nNhấp chuột phải vào Tables và chọn Create rồi chọn Table Đặt tên cho bảng của bạn first_table. Có một tùy chọn để phân vùng bảng của bạn. Đối với first_table này, chúng tôi sẽ không sử dụng phân vùng bảng.\nTable Partitioning trong PostgreSQL là một chủ đề thú vị. Điều thú vị là việc phân vùng bảng đã phát triển qua các phiên bản PostgreSQL. Trong các phiên bản cũ hơn (phiên bản 9 trở về trước), việc phân vùng bảng được hỗ trợ gián tiếp thông qua tính năng kế thừa bảng PostgreSQL (xem bên dưới). Bắt đầu với PostgreSQL phiên bản 10, phân vùng bảng đã trở thành một tính năng khai báo gốc. Điều quan trọng cần nhớ là tập hợp chính xác các tính năng phân vùng bảng được hỗ trợ được gắn với phiên bản PostgreSQL. Vì vậy, hãy đảm bảo bạn tham khảo tài liệu phân vùng bảng gắn liền với phiên bản PostgreSQL bạn đang sử dụng.\nBấm vào Columns để chuyển tới Columns tab. Sau đó bấm vào dấu +. Sau đó nhập col1 cho Tên. Điền text cho kiểu Dữ liệu. Bấm Yes cho Not NULL. Bấm Yes cho Primary Key. Có một tùy chọn để kế thừa các cột từ các bảng khác. Chúng ta sẽ không sử dụng tính kế thừa bảng cho bảng first_table này, nhưng đây là một tính năng thú vị và hữu ích cần lưu ý của PostgreSQL.\nKế thừa bảng trong PostgreSQL có thể là một công cụ hữu ích cho các nhà thiết kế cơ sở dữ liệu. Kế thừa bảng cho phép bảng con kế thừa tất cả các cột của (các) bảng cha của nó. Hơn nữa, bạn cũng có thể viết truy vấn đối với các bảng cha tham chiếu đến các hàng của bảng cha và tất cả các bảng con của nó. Hãy xem ví dụ trong tài liệu kế thừa bảng để hiểu rõ hơn về các chức năng.\nDuyệt qua các tùy chọn có sẵn trên các tab khác và kết thúc trên tab SQL. Sau đó nhấp vào Lưu. Tìm hiểu về Data types Như đã thảo luận trong tài liệu,\n\u0026ldquo;PostgreSQL bao gồm một tập hợp lớn các kiểu dữ liệu tích hợp phù hợp với nhiều ứng dụng. Người dùng cũng có thể xác định loại dữ liệu của riêng mình. Hầu hết các kiểu dữ liệu có sẵn đều có tên và ngữ nghĩa rõ ràng. Một số kiểu dữ liệu được sử dụng thường xuyên là integer cho số nguyên, numeric cho số có thể là phân số, ` text cho chuỗi ký tự, date cho ngày, time cho giá trị thời gian trong ngày và timestamp cho các giá trị chứa cả ngày và giờ.\u0026rdquo;\n1. Numbers\rBạn có thể đọc thêm về các loại dữ liệu số PostgreSQL tại đây . Dưới đây là một vài trích dẫn từ tài liệu:\nLoại integer là lựa chọn phổ biến [cho số nguyên] vì nó mang lại sự cân bằng tốt nhất giữa phạm vi, kích thước lưu trữ và hiệu suất.\nKiểu numeric có thể lưu trữ các số có số lượng chữ số rất lớn. Nó đặc biệt được khuyến khích để lưu trữ số lượng tiền tệ và số lượng khác khi cần độ chính xác. Các phép tính với giá trị số mang lại kết quả chính xác nếu có thể, ví dụ: cộng, trừ, nhân. Tuy nhiên, việc tính toán trên các giá trị số rất chậm so với các kiểu số nguyên hoặc các kiểu thập phân [real và double precision].\nCác kiểu dữ liệu smallserial, serial và bigserial không phải là loại đúng mà chỉ đơn thuần là sự tiện lợi về mặt ký hiệu để tạo các cột định danh duy nhất (tương tự như thuộc tính AUTO_INCREMENT được một số cơ sở dữ liệu khác hỗ trợ).\n2. Character\rBạn có thể đọc thêm về các kiểu dữ liệu ký tự PostgreSQL tại đây. Dưới đây là một vài trích dẫn từ tài liệu:\nSQL định nghĩa hai loại ký tự chính: character varying(n) và character(n), trong đó n là số nguyên dương. Cả hai loại này đều có thể lưu trữ các chuỗi có độ dài tối đa n ký tự (không phải byte). \u0026hellip; Nếu chuỗi được lưu trữ ngắn hơn độ dài đã khai báo, các giá trị của loại character(n) sẽ được đệm khoảng trắng.\nCác ký hiệu varchar(n) và char(n) lần lượt là các bí danh cho ký tự thay đổi (n) và ký tự (n).\nNgoài ra, PostgreSQL còn cung cấp loại text, lưu trữ các chuỗi có độ dài bất kỳ.\nKhông có sự khác biệt về hiệu suất giữa ba loại này, ngoài việc tăng dung lượng lưu trữ khi sử dụng loại có đệm trống và một vài chu kỳ CPU bổ sung để kiểm tra độ dài khi lưu trữ vào cột có giới hạn độ dài. Trong khi character(n) có lợi thế về hiệu năng trong một số hệ thống cơ sở dữ liệu khác, thì PostgreSQL lại không có lợi thế đó; trên thực tế, character(n) thường chậm nhất trong ba loại vì chi phí lưu trữ bổ sung. Trong hầu hết các trường hợp, nên sử dụng text hoặc character varying.\n3. Dates và Times\rBạn có thể đọc thêm về các loại dữ liệu Dates và Times của PostgreSQL tại đây.\nPostgreSQL hỗ trợ các kiểu dữ liệu date, time và timestamp. Kiểu dữ liệu time và timestamp có thể có hoặc không có múi giờ. Mặc định là không có múi giờ. Kiểu dữ liệu timestampz là bí danh của timestamp with time zone. Các kiểu dữ liệu time và timestamp cũng có thể được chỉ định với độ phân giải chính xác 0-6 chữ số trong vài giây. Độ chính xác tối đa là 1 micro giây.\n4. Other datatypes\rBạn có thể đọc thêm về tất cả các loại dữ liệu PostgreSQL tại đây .\nPostgreSQL có một bộ kiểu dữ liệu rất phong phú và có thể mở rộng. Ví dụ: PostgreSQL có một bộ kiểu dữ liệu dành riêng cho JSON json và jsonb hữu ích.\nChúc mừng!\nBạn đã tìm hiểu những kiến thức cơ bản về PostgreSQL Tables và Datatypes..\n"
},
{
	"uri": "/vi/2-preparation/2-3-createrdssg/",
	"title": "Tạo RDS Security Group",
	"tags": [],
	"description": "",
	"content": "Tạo EC2 security group bằng giao diện AWS console: Truy cập giao diện EC2 console.\nTại bảng điều hướng, chọn Security Groups.\nChọn Create Security Group.\nTại mục VPC, chọn VPC bạn muốn tạo security group.\nTại mục Security group name, nhập tên cho security group.\nTại mục Description, nhập mô tả cho security group.\nCấu hình Inbound Rule\nCấu hình Outbound Rule\nClick Create.\nBạn đã tạo thành công security group cho EC2 instance.\n"
},
{
	"uri": "/vi/4-connectordspostgresql/4-3-queryingdata/",
	"title": "Truy vấn dữ liệu",
	"tags": [],
	"description": "",
	"content": "Sau khi sử dụng pgAdmin 4 để kết nối đến RDS PostgreSQL. Bây giờ chúng ta có thể thực hiện các câu lệnh truy vấn cơ bản trong chương này:\nTạo bảng fcj_users trong cơ sở dữ liệu pglab Chèn dữ liệu vào bảng fcj_users Xem tất cả các bản ghi trong bảng Xem tên người dùng và quốc tịch đầy đủ Lấy tất cả người dùng từ Thụy Điển hoặc Mỹ và ngày sinh từ 1980 đến 1990. Sắp xếp danh sách đầu ra giảm dần theo date_of_birth Liệt kê top 5 người dùng trẻ tuổi nhất Danh sách top 5 người dùng lớn tuổi nhất Kiểm tra xem người dùng có thiếu ngày sinh, họ hoặc tên không Nhấp chuột phải vào tên cơ sở dữ liệu để mở menu và nhấp vào nút “Công cụ truy vấn” từ danh sách:\n1.Tạo bảng fcj_users trong cơ sở dữ liệu pglab\nType the following query in the query tool to create a new table:\nCREATE TABLE fcj_user(\ruser_id SERIAL NOT NULL PRIMARY KEY,\rfirst_name VARCHAR(100),\rlast_name VARCHAR(100),\rgender char(1),\rdate_of_birth DATE,\rnationality VARCHAR (20)\r) 2.Chèn dữ liệu vào bảng fcj_users\nChèn dữ liệu vào bảng fcj_users bằng truy vấn sau:\nINSERT INTO fcj_users (first_name,last_name,gender,date_of_birth,nationality) VALUES\r(\u0026#39;Malin\u0026#39;,\u0026#39;Akerman\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1978-05-12\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Tim\u0026#39;,\u0026#39;Allen\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1953-06-13\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Julie\u0026#39;,\u0026#39;Andrews\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1935-10-01\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Ivana\u0026#39;,\u0026#39;Baquero\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1994-06-11\u0026#39;,\u0026#39;Bristish\u0026#39;),\r(\u0026#39;Lorraine\u0026#39;,\u0026#39;Bracco\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1954-10-02\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Alice\u0026#39;,\u0026#39;Braga\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1983-04-15\u0026#39;,\u0026#39;Japanese\u0026#39;)\r(\u0026#39;Marlon\u0026#39;,\u0026#39;Brando\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1924-04-03\u0026#39;,\u0026#39;American\u0026#39;)\r(\u0026#39;Adrien\u0026#39;,\u0026#39;Brody\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1973-04-14\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Peter\u0026#39;,\u0026#39;Carlberg\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1950-12-08\u0026#39;,\u0026#39;Chinese\u0026#39;),\r(\u0026#39;Gemma\u0026#39;,\u0026#39;Chan\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1982-11-29\u0026#39;,\u0026#39;Japanese\u0026#39;),\r(\u0026#39;Chen\u0026#39;,\u0026#39;Chang\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1976-10-14\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Graham\u0026#39;,\u0026#39;Chapman\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1941-01-08\u0026#39;,\u0026#39;Japanese\u0026#39;),\r(\u0026#39;Pei-pei\u0026#39;,\u0026#39;Cheng\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1946-12-04\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Maggie \u0026#39;,\u0026#39;Cheung\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1964-09-20\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Min-sik\u0026#39;,\u0026#39;Choi\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1962-05-30\u0026#39;,\u0026#39;Chinese\u0026#39;),\r(\u0026#39;Yun-fat\u0026#39;,\u0026#39;Chow\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1955-05-18\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;John\u0026#39;,\u0026#39;Cleese\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1939-10-27\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Paddy\u0026#39;,\u0026#39;Considine\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1973-09-05\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Abbie\u0026#39;,\u0026#39;Cornish\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1982-08-07\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Brian\u0026#39;,\u0026#39;Cox\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1946-06-01\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Scatman\u0026#39;,\u0026#39;Crothers\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1910-05-23\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Russell\u0026#39;,\u0026#39;Crowe\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1964-04-07\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Tom\u0026#39;,\u0026#39;Cruise\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1962-07-03\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Darlan\u0026#39;,\u0026#39;Cunha\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1988-07-26\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Willem\u0026#39;,\u0026#39;Dafoe\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1955-07-22\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Paul\u0026#39;,\u0026#39;Dano\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1984-06-19\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Daniel\u0026#39;,\u0026#39;Day-Lewis\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1957-04-29\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Robert\u0026#39;,\u0026#39;De Niro\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1943-08-17\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Marion\u0026#39;,\u0026#39;Brando\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1924-04-03\u0026#39;,\u0026#39;American\u0026#39;),\r(null,\u0026#39;Denden\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1950-01-23\u0026#39;,\u0026#39;Mexican\u0026#39;),\r(\u0026#39;Leonardo\u0026#39;,\u0026#39;DiCaprio\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1974-11-11\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Peter\u0026#39;,\u0026#39;Dinklage\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1969-06-11\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Hiroki\u0026#39;,\u0026#39;Doi\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1999-08-10\u0026#39;,\u0026#39;Japanese\u0026#39;),\r(\u0026#39;Kirsten\u0026#39;,\u0026#39;Dunst\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1982-04-30\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Shelley\u0026#39;,\u0026#39;Duvall\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1949-07-07\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Ralph\u0026#39;,\u0026#39;Fiennes\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1962-12-22\u0026#39;,\u0026#39;British\u0026#39;),\r(\u0026#39;Leandro\u0026#39;,\u0026#39;Firmino\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1978-06-23\u0026#39;,\u0026#39;Swedish\u0026#39;),\r(\u0026#39;Carrie\u0026#39;,\u0026#39;Fisher\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1956-10-21\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Harrison\u0026#39;,\u0026#39;Ford\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1942-07-13\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Darian\u0026#39;,\u0026#39;Cunha\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;1988-07-26\u0026#39;,\u0026#39;American\u0026#39;),\r(\u0026#39;Jodie\u0026#39;,\u0026#39;Foster\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;1962-11-19\u0026#39;,\u0026#39;Chinese\u0026#39;); 3.Xem tất cả bản ghi trong bảng\nType the following query in the query tool to view all recording: SElECT * FROM fcj_users;\n4.Xem tên người dùng và quốc tịch đầy đủ\nNhập truy vấn sau vào công cụ truy vấn:\nSELECT first_name || \u0026#39; \u0026#39; || last_name || \u0026#39; from \u0026#39; || nationality AS \u0026#34;Full name\u0026#34; \u0026amp; nationality FROM fcj_users; 5.Lấy tất cả người dùng từ Thụy Điển hoặc Mỹ và ngày sinh từ 1980 đến 1990. Sắp xếp danh sách đầu ra giảm dần theo date_of_birth\nNhập truy vấn sau vào công cụ truy vấn:\nSELECT * FROM fcj_users\rWHERE nationality = \u0026#39;Swedish\u0026#39; OR\rnationality = \u0026#39;American\u0026#39; AND\rdate_of_birth BETWEEN \u0026#39;1980-01-01\u0026#39; AND \u0026#39;1990-12-31\u0026#39;\rORDER BY date_of_birth DESC; 6.Liệt kê top 5 người dùng trẻ tuổi nhất\nNhập truy vấn sau vào công cụ truy vấn:\nSELECT * FROM fcj_users\rORDER BY date_of_birth DESC\rFETCH FIRST 5 ROW ONLY; 7.Danh sách top 5 người dùng lớn tuổi nhất\nNhập truy vấn sau vào công cụ truy vấn:\nSELECT * FROM fcj_users\rORDER BY date_of_birth ASC\rFETCH FIRST 5 ROW ONLY; 8.Kiểm tra xem người dùng có thiếu ngày sinh, họ hoặc tên không\nSELECT *\rFROM fcj_users\rWHERE date_of_birth IS NULL\rOR first_name IS NULL\rOR last_name IS NULL ; "
},
{
	"uri": "/vi/3-startwithpostgresql/3-4-basicdml/",
	"title": "Basic DML (Data Manipulation Language)",
	"tags": [],
	"description": "",
	"content": "Chương này sẽ nói về truy vấn và DML cơ bản.\nChèn dữ liệu vào bảng Trong pgAdmin tool, nhấp chuột phải vào first_table bên dưới first_schema bên trong first_database của bạn. Chọn Scripts, sau đó nhấp vào INSERT Script Điều này sẽ tạo ra một câu lệnh chèn mẫu soạn sẵn cho bảng mà chúng ta có thể chỉnh sửa.\\\nLàm nổi bật ? giữ chỗ và thay thế nó bằng 'hàng đầu tiên của tôi'. Đừng quên sử dụng dấu ngoặc đơn ' để bao quanh văn bản của bạn. Nhấp vào biểu tượng Play để thực hiện lệnh này. Lệnh này sẽ chạy lệnh của bạn và chèn hàng đầu tiên của bạn. \u0026#39;CHÈN 0 1\u0026#39; nghĩa là gì?\rSố 1 trong INSERT 0 1 có nghĩa là nó đã chèn 1 hàng. Số 0 chỉ áp dụng được nếu bảng sử dụng OID PostgreSQL cổ điển (Mã định danh đối tượng) và nếu vậy thì số 0 đại diện cho OID thực tế được tạo. Nếu không, nó sẽ luôn trả về giá trị 0. Ngày nay, bạn có thể sẽ không tạo bảng bằng OID, nhưng nếu tò mò, bạn có thể đọc thêm về OID trong tài liệu.\rHàng của tôi có được cam kết không?\rTheo mặc định, pgAdmin được đặt ở chế độ bật AutoCommit, vì vậy, hàng mới này phải được cam kết. Bạn có thể xem/thay đổi chế độ AutoCommit bằng cách nhấp vào biểu tượng bên cạnh biểu tượng Play trong Trình soạn thảo truy vấn pgAdmin:\nTruy vấn bảng đầu tiên của chúng tôi Trong pgAdmin của bạn, nhấp chuột phải vào first_table bên dưới first_schema bên trong first_database của bạn. Chọn Tập lệnh, sau đó nhấp vào CHỌN Scripts Nhấp vào biểu tượng Play để thực hiện lệnh này. Lệnh này sẽ chạy lệnh của bạn và bạn sẽ thấy hàng đầu tiên của mình. Tạo bảng bảng thứ hai nếu chưa tồn tại Sử dụng một trong các trình soạn thảo truy vấn, dán lệnh tạo sau đây rồi nhấp vào biểu tượng Play để thực thi lệnh đó: create table if not exists first_schema.second_table(\rcol_pk serial,\rcol_money numeric(12,2),\rcol_short_str varchar(100),\rcol_datetime timestamp(0) without time zone\r); Chèn vào bảng thứ hai Sử dụng một trong các trình soạn thảo truy vấn mở, dán lệnh chèn sau rồi nhấp vào biểu tượng Play để thực thi lệnh đó:\nINSERT INTO first_schema.second_table(\rcol_money, col_short_str, col_datetime)\rVALUES (40.25, \u0026#39;short string\u0026#39;, TIMESTAMP \u0026#39;2004-10-19 10:23:54\u0026#39;) returning col_pk; Lưu ý rằng vì chúng ta đã chỉ định returning col_pk, nên chúng ta thấy giá trị duy nhất được tạo tự động của col_pk trong phần Data Output. Hãy nhớ rằng khi tạo bảng thứ hai, chúng ta đã chỉ định rằng col_pk đã sử dụng kiểu dữ liệu SERIAL (giống như kiểu dữ liệu AUTO_INCREMENT trong các công cụ cơ sở dữ liệu khác).\nThử nghiệm chuyển đổi kiểu dữ liệu Sử dụng trình soạn thảo truy vấn đang mở, dán lệnh chọn sau và nhấp vào biểu tượng Play để thực thi lệnh đó:\nSELECT \u0026#39;40.25\u0026#39; col1, 40.25 col2; Lưu ý trong phần Data Output col1 là kiểu dữ liệu text trong khi col2 là kiểu dữ liệu numeric . Không giống như một số cơ sở dữ liệu khác (cụ thể là Oracle), bạn không cần phải có mệnh đề FROM trong câu lệnh SELECT của mình. Vì vậy, nếu bạn có thói quen viết SELECT 'something' FROM dual trong Oracle, bạn có thể tắt FROM Dual trong PostgreSQL. Không có bảng dual trong PostgreSQL.\nBây giờ hãy chạy truy vấn này:\nSELECT \u0026#39;40.25\u0026#39; col1, 40.25 col2, \u0026#39;40.25\u0026#39;::numeric col3, numeric \u0026#39;40.25\u0026#39; col4, cast(\u0026#39;40.25\u0026#39; as numeric) col5; Lưu ý trong phần Dữ liệu đầu ra col3, col4 và col5 đều là ví dụ về kiểu dữ liệu text đã được chuyển đổi thành kiểu dữ liệu numeric . 3 cột này trình bày 3 cách mà bạn có thể thực hiện chuyển đổi kiểu dữ liệu trong câu lệnh SQL PostgreSQL.\n"
},
{
	"uri": "/vi/4-connectordspostgresql/",
	"title": "Kết nối với RDS PostgreSQL AWS ",
	"tags": [],
	"description": "",
	"content": "Sau khi Amazon RDS khởi tạo db instance, bạn có thể sử dụng bất kỳ ứng dụng máy khách SQL tiêu chuẩn nào để kết nối đến instance. Trong phần này, chúng ta có hai cách để kết nối với RDS PostgreSQL AWS\nSử dụng pgAdmin4 để kết nối Sử dụng psql để kết nối Nội dụng: Sử dụng pgAdmin4 để kết nối với RDS PostgreSQL Sử dụng psql để kết nối với RDS PostgreSQL Truy vấn dữ liệu "
},
{
	"uri": "/vi/2-preparation/2-4-createdbsubnetgroup/",
	"title": "Tạo DB Subnet Group",
	"tags": [],
	"description": "",
	"content": "Tạo DB Subnet Group trên giao diện AWS console theo các bước dưới đây: Truy cập Amazon RDS console\nTại bảng điều hướng, chọn Subnet groups và click Create DB Subnet Group.\nTại mục Name và Description, nhập tên và mô tả cho DB Subnet Group của bạn.\nTại mục VPC, chọn VPC mà bạn muốn tạo DB Subnet Group.\nChọn các subnet mà bạn muốn đưa vào DB Subnet Group. Đảm bảo rằng subnet bạn chọn phải nằm ít nhất trên 2 Az\nClick Create.\nDB Subnet Group sẽ được tạo và hiển thị trong danh sách DB Subnet Group\nDưới đây là một số lưu ý thêm khi bạn tạo DB Subnet Group:\nBạn chỉ có thể tạo DB Subnet Group tại cùng VPC với cơ sở dữ liệu bạn đã tạo. Bạn phải có ít nhất 1 subnet ở mỗi AZ bạn muốn triển khai DB instance của bạn. Bạn chỉ có thể cấu hình DB subnet group 1 lần khi khởi tạo. Nếu bạn muốn thay đổi subnet trong DB subnet group của bạn, bạn phải tạo lại 1 DB subnet group mới. Bạn có thể sử dụng DB subnet group để tạo DB instance ở bất cứ AZ nào nằm trong VPC "
},
{
	"uri": "/vi/3-startwithpostgresql/3-5-rolesusers/",
	"title": "Roles và Users",
	"tags": [],
	"description": "",
	"content": "Chương này sẽ nói về PostgreSQL Roles . Trong PostgreSQL, Roles bao hàm khái niệm về cả người dùng và nhóm. Các câu lệnh CREATE USER và CREATE GROUP thực chất là bí danh của câu lệnh CREATE ROLE. Sự khác biệt là người dùng có vai trò với đặc quyền LOGIN.\nRoles được xác định ở cấp cụm PostgreSQL và có giá trị trong tất cả các cơ sở dữ liệu trong cụm. Roles không được tạo cụ thể cho một cơ sở dữ liệu riêng lẻ.\nTrong PostgreSQL, schemas là khái niệm khác biệt với roles/users. Điều này khác với cơ sở dữ liệu như Oracle.\nExploring Existing Roles Trong pgAdmin, hãy mở rộng mục Login/Group Roles trong PostgreSQL server.\nBạn sẽ thấy các [default roles][https://www.postgresql.org/docs/11/default-roles.html) đã có và được xác định trong cụm PostgreSQL này. Lưu ý rằng có 2 loại biểu tượng mà pgAdmin sử dụng cho roles. Nếu roles có đặc quyền LOIGN thì roles đó sẽ được xác định là người dùng (chẳng hạn như rdsadmin và masteruser). Nếu không, nó sẽ được hiển thị với biểu tượng group.\\\nBạn cũng có thể truy xuất thông tin tương tự bằng cách chạy truy vấn sql sau:\nSELECT rolname FROM pg_roles;\nTạo Role Nhấp chuột phải vào ĐLogin/Group Roles, sau đó chọn Create, sau đó chọn Login/Group role: Đặt tên cho role: first_role. Duyệt qua các tab khác của hộp thoại Create Role nhưng không thay đổi bất cứ điều gì. Kết thúc trên tab SQL. Sau đó nhấp vào Save. Nhấp chuột phải vào first_database và chọn biểu tượng Query Tool. Dán và chạy câu lệnh SQL sau để cấp một số đặc quyền cho vai trò mới của bạn.\nGRANT USAGE ON SCHEMA first_schema TO first_role;\rGRANT SELECT ON first_schema.first_table TO first_role; Chúng tôi đã cấp cho vai trò cả khả năng SELECT từ bảng và cả khả năng sử dụng schemas chứa bảng.\nTạo người dùng mới Nhấp chuột phải vào Login/Group Roles, sau đó chọn Create, sau đó chọn Login/Group role: Đặt tên cho role first_user. Click on the Definition tab. Then enter a Password you will remember. Nhấp vào tab Privileges. Sau đó đặt Can login? thành Yes Nhấp vào tab Membership. Sau đó nhấp vào trường Roles và chọn first_role Cuối cùng, nhấp vào tab SQL để xem SQL trông như thế nào. Sau đó Save Bây giờ, nhấp chuột phải vào nút Servers và chọn Create, sau đó nhấp vào Server\nĐặt tên cho kết nối mới first_user_connection\\\nNhấp vào tab Connection. Nhập RDS endpoint cho tên máy chủ (xem ghi chú bên dưới nếu bạn cần trợ giúp). Nhập first_user cho Tên người dùng. Nhập Mật khẩu cho người dùng mới. Sau đó nhấp vào Save. Mở rộng nút first_user_connection, sau đó mở rộng Databases. Nhấp chuột phải vào first_database, sau đó chọn Query Tool để mở phiên với tư cách first_user. Dán và chạy câu lệnh SQL này select * from first_schema.first_table;\rDán và chạy câu lệnh SQL này để kiểm tra bảng mà chúng ta chưa cấp cho first_role: select * from first_schema.second_table; Đọc thêm về các phương pháp hay nhất để quản lý User/Role dùng PostgreSQL\nBạn muốn tạo thêm người dùng DBA (tương tự như người dùng chính) cho phiên bản RDS hoặc Aurora PostgreSQL của mình? Hãy thử [tập lệnh này](https://aws.amazon.com/premiumsupport/know-center/rds-aurora-postgresql-clone-master-user/):\r```\r--replace thepassword with a real password\rCREATE ROLE new_dba_user WITH PASSWORD 'thepassword' CREATEDB CREATEROLE LOGIN;\rGRANT rds_superuser TO new_dba_user;\r```\r"
},
{
	"uri": "/vi/5-helpfulresources/",
	"title": "Tài liệu tham khảo",
	"tags": [],
	"description": "",
	"content": "Dưới đây là một số liên kết đến nội dung bổ sung có liên quan:\nManaging PostgreSQL users and roles RDS for PostgreSQL Common administrator responsibilities on Amazon RDS and Amazon Aurora for PostgreSQL databases Using IAM authentication to connect with pgAdmin Amazon Aurora PostgreSQL or Amazon RDS for PostgreSQL Securing Amazon RDS and Aurora PostgreSQL database access with IAM authentication Working with RDS and Aurora PostgreSQL logs: Part 1 Working with RDS and Aurora PostgreSQL logs: Part 2 "
},
{
	"uri": "/vi/2-preparation/2-5-createec2appsv/",
	"title": "Tạo EC2 instance cho App Server",
	"tags": [],
	"description": "",
	"content": "Tạo EC2 instance cho App Server theo các bước sau: Truy cập Amazon EC2 console.\nClick Launch Instance.\nChọn AMI. Với App Server, bạn có thể chọn Linux AMI, chẳng hạn như Amazon Linux 2.\nChọn instance type. Loại instance mà bạn chọn sẽ phụ thuộc vào yêu cầu của App Server. Ví dụ, nếu bạn đang chạy website với lưu lượng truy cập cao, bạn sẽ cần instance type lớn với nhiều CPU và memory hơn.\nTại mục Key Pair, chọn keypair mà bạn đã tạo trước đó hoặc click Create new key pair để tạo 1 keypair mới.\nĐịnh cấu hình chi tiết của instance. Điều này bao gồm những thứ như số lượng instance sẽ khởi chạy, cấu hình mạng và cấu hình lưu trữ.\nTại mục Network settings\nChọn VPC chứa EC2 App Server Chọn Subnet Enable Auto-assign public IP Thêm security group cho EC2 App Server mà bạn đã tạo trước đó. Security group là 1 tường lửa kiểm soát lưu lượng đi với đến EC2 của bạn Đánh giá và khởi tạo instance Sau khi khởi chạy instance, bạn có thể kết nối với instance đó bằng ứng dụng SSH client, chẳng hạn như MobaXterm hoặc PuTTY. Sau khi kết nối, bạn có thể cài đặt app server và triển khai ứng dụng của mình.\n"
},
{
	"uri": "/vi/3-startwithpostgresql/3-6-catalodatadictonary/",
	"title": "Catalog and Data dictionary",
	"tags": [],
	"description": "",
	"content": "Chương này giới thiệu PostgreSQL Data Dictionary.\nThe pg_catalog schema Ngoài các public schemas do người dùng tạo, mỗi cơ sở dữ liệu còn chứa một pg_catalog schema, chứa các bảng hệ thống và tất cả các kiểu dữ liệu, hàm và toán tử tích hợp sẵn.\nĐây là một tập hợp các bảng được sử dụng để lưu trữ siêu dữ liệu động và tĩnh cho cơ sở dữ liệu PostgreSQL và có thể được coi là “từ điển dữ liệu” cho cơ sở dữ liệu. Các bảng này được sử dụng cho các hoạt động thuộc loại “sổ sách kế toán” nội bộ. Tất cả các bảng danh mục Hệ thống đều bắt đầu bằng tiền tố pg_* và có thể tìm thấy trong pg_catalog schema\nTrong pgAdmin, hãy mở rộng nút rdspg-fcj-labs, sau đó mở rộng nút Databases, sau đó mở rộng nút first_database, sau đó mở rộng nút Catalogs, sau đó mở rộng PostgreSQL Catalog, sau đó mở rộng Tables. Bạn có thể xem các bảng trong pg_catalog schema.\nNhấp vào first_database, sau đó chọn biểu tượng Query Tool\nDán và chạy lệnh này để xem ví dụ về truy vấn trực tiếp pg_catalog: s select * from pg_tables where schemaname='pg_catalog'; The Statistics Collector Views (also part of pg_catalog) Trình thu thập số liệu thống kê là một hệ thống con đặc biệt thu thập thông tin động thời gian chạy về các hoạt động hiện tại trong phiên bản cơ sở dữ liệu. Ví dụ: số lượt xem của người thu thập số liệu thống kê rất hữu ích để xác định tần suất truy cập một bảng cụ thể và liệu bảng có được quét hoặc truy cập bằng chỉ mục hay không.\nDán và chạy lệnh này để xem ví dụ về một trong các chế độ xem Statistics Collector: SELECT * FROM pg_stat_activity WHERE STATE = 'active';\nNhấp vào nút rds-pg-labs. Sau đó nhấp vào Dashboard. Sau đó nhấp vào Sessions trong phần Hoạt động của máy chủ. Tại đây, pgAdmin đang hiển thị cho bạn thông tin pg_stat_activity tương tự cho cụm PostgreSQL của bạn.\nPerformance Insights là một cách tuyệt vời để trực quan hóa hoạt động hiện tại và lịch sử cũng như đợi các sự kiện. Chúng tôi khuyến khích bạn bắt đầu với Thông tin chi tiết về hiệu suất để chẩn đoán liên quan đến hiệu suất.\nDán và chạy lệnh này để xem ví dụ về một trong các chế độ xem Statistics Collector: select * from information_schema.tables; "
},
{
	"uri": "/vi/6-cleanup/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/2-preparation/2-6-createec2bastionhost/",
	"title": "Tạo EC2 instance bastion h ",
	"tags": [],
	"description": "",
	"content": "\rChúng ta sẽ kết nối đến instance RDS PostgreSQL bằng pgAdmin4 thông qua EC2 bastion host\nTạo EC2 instance cho bastion host, làm theo các bước dưới đây Truy cập giao diện Amazon EC2 console.\nClick Launch Instance.\nĐặt tên cho EC2 bastion.\nChọn AMI. Bạn có thể chọn Amazon Linux 2 cho app server Choose an instance type. The instance type that you choose will depend on the requirements of your app server. For example, if you are running a high-traffic website, you will need a larger instance type with more CPU and memory.\nChọn instance type. Instance type bạn chọn sẽ tùy thuộc vào yêu cầu của app server. Ví dụ: nếu bạn đang chạy một trang web có lưu lượng truy cập cao, bạn sẽ cần instance type lớn hơn với nhiều CPU và bộ nhớ hơn. Tại mục Key Pair, chọn keyair mà bạn đã tạo hoặc click vào Create new key pair để tạo 1 keypair mới Tại mục Network settings\nChọn VPC chứa EC2 app server Chọn Subnet Chọn Enable Auto-assign public IP Thêm security group cho EC2 app server mà bạn đã tạo trước đó. SG là một 1 firewall kiểm soát lưu lượng đi và đến instance của bạn Review và launch instance\n"
},
{
	"uri": "/vi/3-startwithpostgresql/3-7-sessionparameters/",
	"title": "Session parameters",
	"tags": [],
	"description": "",
	"content": "Phần này sẽ nói về PostgreSQL Parameters . Cụ thể, nó sẽ tập trung vào các thông số có thể thay đổi ở cấp độ phiên. Đối với các tham số trên toàn hệ thống, bạn sẽ tận dụng cơ chế Parameter Group của RDS/Aurora.\nTrong pgAdmin, nhấp vào nút rdspg-fcj-labs, sau đó nhấp vào Dashboard, sau đó nhấp vào Configuration. Phần này hiển thị cho bạn cài đặt hiện tại của tất cả PostgreSQL parameter settings.\nTrong thanh tìm kiếm, gõ search Lọc danh sách cài đặt tham số.\nNhấp vào first_database, sau đó chọn biểu tượng Query Tool. Sau đó dán và chạy SQL sau: SELECT * FROM pg_settings where context = 'user'; Lệnh này hiển thị cho bạn các phiên tham số có thể được thay đổi cho một phiên cũng như cài đặt hiện tại của chúng.\nDán và chạy câu lệnh SQL sau: show search_path Lệnh SHOW là một cách khác để xem giá trị hiện tại của cài đặt của bạn.\nDán và chạy câu lệnh SQL sau: show all Lệnh này chỉ cho bạn một cách khác để xem giá trị hiện tại của tất cả cài đặt tham số của bạn.\nDán và chạy câu lệnh SQL sau: select * from first_table; Lệnh này không thành công vì PostgreSQL không thể tìm thấy bảng có tên first_table trong các lược đồ ở search_path hiện tại.\\\nDán và chạy câu lệnh SQL sau: SET search_path TO first_schema, public; Dán và chạy lại câu lệnh SQL sau: select * from first_table; Lệnh này hiện đã hoạt động vì chúng ta đã cập nhật cài đặt tham số search_path.\nKhi thực hiện các thay đổi đối với tham số hệ thống thông qua RDS/Aurora Parameter Groups, bạn nên xác nhận rằng thay đổi tham số của mình đã được áp dụng bằng cách sử dụng một trong các kỹ thuật ở trên, chẳng hạn như \u0026ldquo;SHOW ALL\u0026rdquo;, để xác nhận rằng giá trị tham số dự kiến là có hiệu lực. Đôi khi mọi người có thể nhầm lẫn vì có thể thực hiện thay đổi Nhóm tham số nhưng thay đổi cài đặt tham số thực tế không xảy ra cho đến lần khởi động lại tiếp theo. Xác nhận giá trị bằng cách sử dụng \u0026ldquo;SHOW ALL\u0026rdquo; hoặc một trong các phương pháp khác có thể giúp bạn tránh nhầm lẫn và mất thời gian\n"
},
{
	"uri": "/vi/2-preparation/2-7-createrdsdb/",
	"title": "Tạo RDS PostgreSQL DB",
	"tags": [],
	"description": "",
	"content": "Để tạo 1 RDS PostgreSQL DB, làm theo các bước dưới đây Truy cập đến giao diện Amazon RDS console. Click Create database.\nTại mục Database engine, chọn PostgreSQL.\nTại mục Version, chọn version PostgreSQL bạn muốn sử dụng.\nTại mục Template, chọn template cho db instance của bạn. Template là cấu hình được khởi tạo trước cho DB instance\nTại mục Availability và Durability, DB instance identifier, đặt tên cho Tại mục DB instance.\nTại mục DB instance identifier, nhập một tên duy nhất cho rds instance.\nTại mục Master username, nhập tên người dùng cho người dùng chính của rds instance.\nTại mục Master password, nhập mật khẩu cho người dùng chính của rds instance.\nTại mục DB instance class, chọn instance class mà bạn muốn sử dụng cho db instance của mình. Instance class sẽ xác định số CPU và bộ nhớ được phân bổ cho db instance của bạn.\nTại mục Storage, chọn dung lượng lưu trữ mà bạn muốn phân bổ cho db instance của mình.\nTại mục Connectivity, chọn Connect to a EC2 compute resource, sau đó chọn App server instance mà bạn đã tạo.\nTại mục DB subnet group, chọn DB subnet group mà bạn muốn sử dụng cho DB instance của mình.\nTại mục VPC security groups, chọn security group mà bạn muốn sử dụng cho DB instance của mình.\nClick vào Additional configuration, Nhập 5432 cho database port\nTại mục Database authentication, chọn phương thức mà bạn muốn sử dụng\nTại mục Monitoring, chọn các tùy chọn giám sát mà bạn muốn sử dụng cho phiên bản cơ sở dữ liệu của mình\nClick vào Additional configuration:\nTại mục Database option, điền tên cho cơ sở dữ liệu bạn muốn tạo sau khi khởi chạy RDS PostgreSQL\nTại mục DB parameter group, giữ cấu hình mặc định\nTại mục Backup, chọn các tùy chọn sao lưu mà bạn muốn sử dụng cho db instance của mình.\nClick Create database.\nDatabase instance của bạn sẽ được tạo và hiển thị trong danh sách các database instance. Bạn có thể kết nối với nó bằng ứng dụng PostgreSQL client, chẳng hạn như psql, pgAdmin4. Để thực hiện việc này, bạn sẽ cần hostname, port, tên người dùng và mật khẩu cho db instance của bạn.\nDưới đây là một số điều cần lưu ý khi tạo cơ sở dữ liệu RDS PostgreSQL: Click here\rBạn chỉ có thể tạo một RDS PostgreSQL DB trong VPC nằm trong cùng AWS region với công cụ cơ sở dữ liệu mà bạn dự định sử dụng. Bạn phải chọn instance class tương thích với phiên bản PostgreSQL mà bạn muốn sử dụng. Bạn có thể chọn tạo db instance của mình trong một Availability Zone (AZ) hoặc trong nhiều AZ. Nếu chọn tạo db instance trong nhiều AZ, bạn sẽ có thể tận dụng các tính năng high availability và disaster recovery Bạn có thể chọn bật mã hóa cho db instance của mình. Điều này sẽ mã hóa dữ liệu của bạn khi lưu trữ và truyền tải. Bạn có thể chọn bật sao lưu cho db instance của mình. Điều này sẽ cho phép bạn khôi phục cơ sở dữ liệu của mình về thời điểm trước đó nếu có sự cố. "
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]